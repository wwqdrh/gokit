package dns

import (
	"errors"
	"fmt"
	"os"
	"strings"

	"github.com/wwqdrh/gokit/logger"
	"github.com/wwqdrh/gokit/nettool/common"
)

const (
	resolverDir      = "/etc/resolver"
	ktResolverPrefix = "kt."
	resolverComment  = "# Generated by KtConnect"
)

// HandleExtraDomainMapping handle extra domain change
func HandleExtraDomainMapping(extraDomains map[string]string, localDnsPort int, includeDomains string) {
	for _, suffix := range getAllDomainSuffixes(extraDomains) {
		createResolverFile(fmt.Sprintf("%s.local", suffix), suffix, common.Localhost, fmt.Sprintf("%d", localDnsPort))
	}
	for _, suffix := range strings.Split(includeDomains, ",") {
		if len(suffix) > 0 {
			createResolverFile(fmt.Sprintf("%s.local", suffix), suffix, common.Localhost, fmt.Sprintf("%d", localDnsPort))
		}
	}
}

// RestoreNameServer remove the nameservers added by ktctl
func RestoreNameServer() {
	rd, _ := os.ReadDir(resolverDir)
	for _, f := range rd {
		if !f.IsDir() && strings.HasPrefix(f.Name(), ktResolverPrefix) {
			if err := os.Remove(fmt.Sprintf("%s/%s", resolverDir, f.Name())); err != nil {
				logger.DefaultLogger.Warnx("%s: Failed to remove resolver file %s", nil, err.Error(), f.Name())
			}
		}
	}
}

func SetNameServer(dnsServer string, dnsMode string) error {
	return errors.New("not support darwin")
}

func createResolverFile(postfix, domain, dnsIp, dnsPort string) {
	resolverFile := fmt.Sprintf("%s/%s%s", resolverDir, ktResolverPrefix, postfix)
	if _, err := os.Stat(resolverFile); err == nil {
		_ = os.Remove(resolverFile)
	}
	resolverContent := fmt.Sprintf("%s\ndomain %s\nnameserver %s\nport %s\n",
		resolverComment, domain, dnsIp, dnsPort)
	if err := os.WriteFile(resolverFile, []byte(resolverContent), 0644); err != nil {
		logger.DefaultLogger.Warnx("%s: Failed to create resolver file of %s", nil, err.Error(), domain)
	}
}

func getAllDomainSuffixes(extraDomains map[string]string) []string {
	var suffixes []string
	for domain := range extraDomains {
		i := strings.LastIndex(domain, ".")
		if i < 0 {
			continue
		}
		suffix := domain[i+1:]
		if !Contains(suffixes, suffix) {
			suffixes = append(suffixes, suffix)
		}
	}
	return suffixes
}
